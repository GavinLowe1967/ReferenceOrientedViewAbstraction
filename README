Plan for improving EffectOnStore.

0. Split store into two parts:

  - mcMissingCandidatesStore: for MissingInfo objects with at least one
    incomplete MissingCommon object, storing the MissingInfo against the head
    of each MissingCandidates list;

  - store, for MissingInfo objects for which all the MissingCommon objects are
    complete, storing the MissingInfo against the head of missingViews.

1. Initially store each MissingInfo according to its first MissingCommon value
(if any):

  - In commonStore, against the parameters of the MissingCommon;

  - In mcMissingCandidatesStore, against the heads of the MissingCandidates
    lists of the first MissingCommon.

2. In MissingCommon.updateMissingViews, pass in current ViewSet.  For the
current MissingCommon object, in each Missingcandidates list whose head
matches cv, remove longest prefix of values in ViewSet; return list of new
head views against which it should be stored (or special value if the
MissingCommon is done).

3. When first MissingCommon done (via updateMissingCommon or
updateMCMissingViews), update second MissingCommon (if any), and re-store in
commonStore and mcMissingCandidateStore, as above.

4. When all MissingCommon done, update missingViews by removing longest prefix
of views now in the ViewSet, and re-store against the next in the list.

Order of implementation: 

A. Split store as in 0 (but still store against all keys); split
  MissingInfo.updateMissingViews according to the two cases, and change the
  calls from EffectOnStore.complete; update sanityCheck; update report.

B. In mcMissingCandidateStore, only store against heads, as in 1 (but still
  include in store); make changes as in 2.

C. Delay adding to store until all MissingCommon done (as in 4); assume at most
  one MissingCommon for the moment; but store against all of missingViews.

D. Update to store in store only against head missingViews, as in 4; change
  MissingInfo.updateMissingViews appropriately.

E. In mcMissingCandidatesStore, store just against the missing heads of the
next MissingCommon, as in first part of 1, and in 3.

F. In missingCommon, store just information for the first MissingCommon.

Result of EffectOnStore.report after step A.

store: size = 3574
  # MissingInfos = 203,154
  MissingInfos size = 474,290
commonStore: size = 42
  # MissingInfos = 5,503
  MissingInfos size = 11,334
mcMissingCandidatesStore: size = 721
  # MissingInfos = 10,468
  MissingInfos size = 25,942

After step C:

store: size = 3574
  # MissingInfos = 201,668
  MissingInfos size = 470,283
commonStore: size = 42
  # MissingInfos = 5,568
  MissingInfos size = 11,783
mcMissingCandidatesStore: size = 621
  # MissingInfos = 9,823
  MissingInfos size = 24,206

After Step D:

store: size = 2110
  # MissingInfos = 90,805
  MissingInfos size = 197,335
commonStore: size = 42
  # MissingInfos = 5,568
  MissingInfos size = 11,783
mcMissingCandidatesStore: size = 621
  # MissingInfos = 9,823
  MissingInfos size = 24,206




=======

Trace sequence of calls process -> processTransition ->
instantiateTransitionTemplateBy -> extendTransitionTemplateBy -> isExtendable
-> findReferencingView: is there repeated work here?

* Look at the FIXMEs in Extendability.scala

* Avoid repeated work within calls to extendUnif

* With singleRef, in effectOn, if a secondary component c1 gains a reference
  to another component c2, we form the corresponding view c1 || c2 (via
  c2Refs).  Could we achieve the same effect more simply via a call to
  effectOn for pre.principal || c2?

* Improve EffectOnStore and related code.

============

Within effectOn, we might need to delay adding Views for a number of reasons.

1. If one of preCpts or cpts has a missing reference to a component in the
other, but the corresponding view is not a current view -- already supported.
EffectOnStore stores a mapping missing -> nv indicating that if all of missing
are added, then nv can also be added.

2. If each of preCpts and cpts have the same missing reference, and there is
not some way of instantiating that state to give a current view.  Need to
store the principals of each, and the list of such missing identities, i.e. a
mapping (servers, princ1, princ2, pids) -> nv such that if for each pid in
pids there is a component c such that (servers || princ1 || c) and (servers ||
princ2 || c) are added, then nv can be added.


============

- Do profiling on lazySet.  First, correct Node to allow unlocking when
  marked.  Also send decoupling signal only for A nodes.

- Check every event includes at least one active process. 

- Allow user to specify that only a single referenced state is included in
  Views.

- In Unification.combineX, don't remap components with index in map fst unifs.
  Or remap each state in turn. (low priority)

- In allUnifs, if !changedServers, try to do unifiation of component that
  changes state first.

- Clear package.debugging.

- Why are so many Views/Transitions not new?

- In TransitionTemplates, if the missing component is not synchronising, and
  there's a reference to it from a present component, use that fact to improve
  searching (done?).

=============

Thoughts on adding concurrency.

In Checker:

- In first stage of each ply, need to protect nextNewViews, newTransitions,
newTransitionTemplates.  CAS on done before debugging.

- In second stage, need to protect sysAbsViews, transitions,
  transitiontemplates (if done concurrently).

- Need to protect System.mapCache and Checker.isExtendableCache


=======================================

Implementation notes.

Main state:

- sysAbsViews: ViewSet: all views found.

- nextNewViews: ArrayBuffer[ComponentView]: all new views found on the current
  ply, to be considered on the next ply.

- transitions: TransitionSet: the extended transitions found so far.  An
  extended transition represents the pre- and post-states and the event, and
  includes (1) all states referenced by the initial state of the principal
  component, (2) all other components synchronising on the transition, (3) all
  components to which a process gains a reference.

- transitionTemplates: TransitionTemplateSet: the transition templates found
  so far.  A transition template can be thought of as a transition with a
  "hole" for a component to be slotted into.  Formally it's a tuple (pre,
  post, id, oe) representing all transitions pre \union st --> post \union st'
  such that (1) st and st' have identity id; (2) pre is compatible with pre;
  (3) if oe = Some(e) then st -e-> st', otherwise st = st'.

- newTransitions: ArrayBuffer[Transition]: the new transitions found on the
  current ply.

??? Why not new transitionTemplates ???


In the first half of each ply, new views are added to nextNewViews; in the
secondhalf, they are added to sysAbsViews.  Likewise with Transitions.

The function process acts on a single view found on the previous ply. It
calculates all the transitions from the view, together with the identities of
other components relevant to the view.  It then calls processTransition on
each such transition.  It also calls effectOfPreviousTransitions and
effectOfPreviousTransitionTemplates on the view.

processTransition: if the transition is complete, requires no outside
processes, it is added to newTransitions (via addTransition).  Otherwise, it
is added to transitionTemplates ???, and instantiateTransitionTemplate is
called. 

addTransition adds a transition to newtransitions, and calls effectOnOthers

effectOnOthers considers the effect of a new transition on views found on
previous plys (what about this ply???).  For each such view matching the pre
servers, it calls effectOn.

effectOn considers the effect of a transition pre -e-> post on another view
cv.  It forms all ways of combining pre and cv, calculates the corresponding
post-view for cv.princ, and adds it to nextNewViews. 

instantiateTransitionTemplate considers all ways of instantiating a transition
template, by considering all ways of instantiating the extra component.  For
each view in sysAbsViews, it calls instantiateTransitionTemplateBy.

instantiateTransitionTemplateBy finds all transitions of the extra component
that match the transition template.  For each, it forms the extended
transition, and calls addTransition. 

effectOfPreviousTransitions considers the effect of all previous transitions
on a view cv found on the previous ply.  For each, it calls effectOn. 

effectOfPreviousTransitionTemplates, given a view cv found on the previous
ply, iterates over all previous transition templates, and tries to use cv to
instantiate the extra component, calling instantiateTransitionTemplateBy.

======================================================

With lockBasedStack.csp, debugger gives error when selecting "6".  The
concretization does not include the node N1 referenced by N0.  Need to store
the contributing view(s) for each concretization.  Done: used in
Debugger.expandConc.  This needs testing more.  It might be that
lockBasedStack needs a second synchronisation between thread and watchdog.
But the debug info isn't clear at present.  I think the contributing view also
needs to be stored at l463 of Checker.scala.

=======================================================

We need to consider:

1. Transitions from new abstractions.  process -> processTransition.
  * Giving new TransitionTemplates
  * Giving new ExtendedTransitions

2. The effect of previous extended transitions on new abstractions.
process -> effectOfPreviousTransitions -> effectOn

3. The effect of new abstractions on previous transition templates, creating
new extended transitions.  processTransition -> addTransition ->
effectOnOthers -> effectOn.

4. The effect of new extended transitions on previous abstractions.
effectOfOthers -> effectOn.


ExtendedTransitions include all the components that synchronise on the
transition.  Do they also include all the components to which a process
receives a reference, e.g. in a getNext.T0.N0.N1 transition?  I think such
cases have to be treated as transition templates, since if we find a new state
for N1 subsequently, that will create a new ExtendedTransition.  However, if
the principal component passes a reference to another component or a server,
e.g. a setNext.T0.N0.N1 transition, then the component for that reference will
be held by the principal in the prior state and so will be in the prior view.

===================================

Def: a concretization conc is strongly consistent with a set V of views if
there exists a global state g \in gamma(V) such that conc \sqsubseteq g.

This is too strong for algorithmic checking, so we overapproximate it by the
following condition. 

Def: a concretization conc is weakly consistent with a set V of views if for each
component state st in conc, there is a view v \in V where st is the principal
component, and v and conc agree on common processes (i.e. they agree on the
states of servers and of all components with common identities).

Say "consistent" for "weakly consistent". 

Lemma: strongly consistency implies consistency.  

Proof: suppose conc strongly consistent with V.  So there is some g \in
gamma(V) such that conc \sqsubseteq g.  So \alpha(g) \subseteq V.  Consider a
component state st in conc, and let v \in \alpha(g) be the view of g with st
as the principal component.  Then v satisfies the requirement of consistency.

So we can safely overapproximate the strongly compatible components by the
compatible ones.  (I don't think the converse holds.)

Def: Suppose st is a component state whose identity is not in the
concretization conc.  Then, given a set V of views, st is strongly consistent
with conc and V if conc U st is strongly consistent with V.

Conj: Suppose st is strongly consistent with conc and V.  Then (1) conc is
strongly consistent with V; (2) there is a view v \in V where st is the
principal component, and v and conc agree on common processes; (3) for every
component st1 in v that has a reference to st, there is a view v \in V where
st1 is the principal component, and v and conc U st agree on common processes.

Proof: Suppose st is strongly consistent with conc and V.  So there is a
global state g \in \gamma(V) such that conc U st \sqsubseteq g.  So \alpha(g)
\subseteq V.  (1) So conc \sqsubseteq g, so conc strongly consistent with V.
(2) is satisfied by taking v \in \alpha(g) to be the view of g with st as the
principal component.  (3) similar but for st1. 



=========================================


Creating abstract transitions.

For the moment, ignore server views.

We need to perform a case analysis over the processes involved in the
synchronisation: 

* Just the principal component: done as Case 1. 

* Principal component + server: done as Case 2.

* Principal component + a passive component.  Subcase analysis:
  
  - That passive component is in the view: not yet done;

  - That passive component is not in the view: current focus **

* Principal component + server + passive component.  Not yet done; similar
  subcase analysis. 


Then extracting views from the post-transition concretization.


Assumptions:

- Each synchronisation involves a principal component and at most one passive
  component (and maybe the servers).  