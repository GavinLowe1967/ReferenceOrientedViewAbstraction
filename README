-- TUESDAY We are considering the same case twice for some reason.
   EffectOnUnificaiton.extendUnifSingleRef see the same (newCpts,unifs)
   twice (assertion line 315).  

   I think getCombiningMaps is creating cross references beyond those in
   tuples.  Shouldn't include in otherArgs identities of components in
   pre.components -- done.  Also shouldn't map identities to match parameters
   in pre.components ....


- Investigate requiring cross refs only from the principal, or from a
  secondary component if the principal has a reference to the same
  component. -- done as switch; but this leads to more states with
  laztSetNoDel.

-- If there are no unifications, and we have previously seen this change of
   servers, and that led to a view being added, do we need to consider this
   again?  This is part 4 of optimisation 5.
  * In EffectOn.processInducedInfo, if view is added (or already there), call
     cv.addDoneInduced.
  * In EffectOnUnification.isSufficientUnif, call cv.doneInducedContains :
    if(changedServers) unifs.nonEmpty || cv.addDoneInduced(postServers)
    Better: change the map to store (unification,postServers) pairs.  No, we
    need to store the actual states of pre with which components are unified.
  No.  There might be multiple renamings associated with this case, some of
  which satisfy the side conditions and some don't.  We need to consider these
  separately.

** EffectOnUnification.remapToCreateCrossrefs: maintain bitmap corresponding
   to map.  -- done

-- Tidy up EffectOnUnification.getOtherArgsBitMapForSingleRef, and improve

-- Based on the choice of which parameters to unify, can we perform
   optimisation 8 earlier?  In EffectOnUnification.extendUnifSingleref,
   immediately after calulating crossRefs?

-- Split Concretization into separate class from ComponentView: (1) combine
   View and ComponentView; (2) factor out debugging information (classes
   ComponentView0, Concretization0 without debugging information).  Then
   compile in the order ComponentView0 -> Concretization0 -> (ComponentView,
   Concretization). ??

-- Look at EffectOnUnification.combine: it's about 80% of Checker time.  Idea
   on page 38 of printout.

-- Return information about cross references from EffectOnUnification.combine,
   and use in missingCrossRefs.

*** Do we do what's described in clause 3 of Def 13 (concerning missing
    components in primary induced transitions with singleRef.)?

*** Consider the optimisations at the end of Section 9.

Make maps smaller.

------------------------------------------------------------------

Optimisation 8

-- Normalise cross refs -- done

-- pass through for subsequent use -- done

-- Should we also be storing when induced transition happens, or is that
   captured elsewhere? -- captured by the earlier optimisation.

- Calculate crossRefs in EffectOn.apply -- done

- Subset relation over crossRefs.  It might help to keep each crossRefs
  sorted. -- done

- In ComponentView store set of (post.fixed, v, pi |> post.fixed, crossRefs)
  tuples: map within v from (post.fixed, pi |> post.fixed) to the set of all
  such crossRefs. -- done

- In EffectOn.apply, calculate crossRefs for each pi -- done

- If there is a corresponding tuple stored against v, bail out before calling
  processInducedInfo. -- done

- In EffectOn.processInducedInfo, case missing empty, missingCommons
  non-empty, store (post.fixed, v, pi |> post.fixed, crossRefs). -- done

============

lazySet with bound of 44.  newViewCount 155M; addedViewCount 1.1M;
EffectOnStore.add with primary, unifs empty, servers changed, missing
non-empty 88M.  343 min

Fix bug with EffectOnStore so that sanityCheck passes.

Relevant call path:

EffectOnStore.complete (entry from candidateForMCStore) ->
mi.updateMissingCommon -> mc.updateWithNewMatch ->
MissingCommon.updateMissingCandidates.

Could always re-register against mc.missingHeads. 

Get singleRef to work with omitted references. -- ok I think

This one is done. 

I think that with singleRef we need to consider more remappings, maybe
remapping to any parameter in pre.components (subject to normal constraints).
Consider transition

(fixed(N1,T1); 40(T1,N1), 13(N2,Null,N1)) -> (fixed'(N1); 38(T1), 13(N2,Null,N1))

on

(fixed(N1,T1); 110(T2,N2,N1), 36(N1,N2,Null))

This should induce transition to

(fixed'(N1); 110(T2,N2,N1), 36(N1,N2,Null))

corresponding to mapping {T1->T1, T2->T2, N1->N1, N2->N2}, assuming existence
of view

(fixed(N1,T1); 13(N2,Null,N1), 36(N1,N2,Null))

(to satisfy condition (b) of Def 13).  But at present it considers just the
mapping {T1->T1, T2->T2, N1->N1, N2->N3} and fails to produce the induced
transition because we are missing view

(fixed(N1,T1); 13(N2,Null,N1), 36(N1,N3,Null))

=========

In Unification.combine, return two results.

1. A Combine.result, as present, but ignoring princRenames.

2. For each choice of unifs, for each way of mapping cv.principal.id to match
a newly acquired parameter of a secondary component c that changes state, add
that mapping, and then form all remappings, including mapping to parameters of
c in post.  Return (remapped state, unifs, post-state of c).  

In EffectOn, treat above results as follows:

1(a). At present, but without the contribution from c2Refs, so without adding
*all* parameters of pre.cpts to newServerIds.

2. Only as with c2Refs, for the relevant secondary component (which is the
principal of the new view).


============

When singleRef, if the present secondary component gains a reference to a
missing secondary component, at present this is captured within effectOn (via
c2Refs).  E.g.
  (f; Thread(t, n, n'), Node_x(n, null)) -setNext.t.n.n'->
    (f'; Thread'(t, n, n'), Node_x(n, n')).
on 
  (f; Node_y(n', n''), Node_z(n'', n''') 
induces transition to 
  (f'; Node_x(n, n'), Node_y(n', n'')
This doesn't feel like the best way.  However, some states of the missing
secondary component will be found only after the transition is expanded.  That
means it will be necessary to store relvant information, e.g. when we
subsequently find a view
  (f; Node_?(n', ?), ?)   or   (f; Thread(t, n, n'), Node_?(n', ?))
create the derived transition.  (The latter looks better.)


===============

Plan for improving EffectOnStore.

0. Split store into two parts:

  - mcMissingCandidatesStore: for MissingInfo objects with at least one
    incomplete MissingCommon object, storing the MissingInfo against the head
    of each MissingCandidates list;

  - store, for MissingInfo objects for which all the MissingCommon objects are
    complete, storing the MissingInfo against the head of missingViews.

1. Initially store each MissingInfo according to its first MissingCommon value
(if any):

  - In commonStore, against the parameters of the MissingCommon;

  - In mcMissingCandidatesStore, against the heads of the MissingCandidates
    lists of the first MissingCommon.

2. In MissingCommon.updateMissingViews, pass in current ViewSet.  For the
current MissingCommon object, in each Missingcandidates list whose head
matches cv, remove longest prefix of values in ViewSet; return list of new
head views against which it should be stored (or special value if the
MissingCommon is done).

3. When first MissingCommon done (via updateMissingCommon or
updateMCMissingViews), update second MissingCommon (if any), and re-store in
commonStore and mcMissingCandidateStore, as above.

4. When all MissingCommon done, update missingViews by removing longest prefix
of views now in the ViewSet, and re-store against the next in the list.

Order of implementation: 

A. Split store as in 0 (but still store against all keys); split
  MissingInfo.updateMissingViews according to the two cases, and change the
  calls from EffectOnStore.complete; update sanityCheck; update report.

B. In mcMissingCandidateStore, only store against heads, as in 1 (but still
  include in store); make changes as in 2.

C. Delay adding to store until all MissingCommon done (as in 4); assume at most
  one MissingCommon for the moment; but store against all of missingViews.

D. Update to store in store only against head missingViews, as in 4; change
  MissingInfo.updateMissingViews appropriately.

E. In mcMissingCandidatesStore, store just against the missing heads of the
next MissingCommon, as in first part of 1, and in 3.

F. In missingCommon, store just information for the first MissingCommon.

Result of EffectOnStore.report after step A.

store: size = 3574
  # MissingInfos = 203,154
  MissingInfos size = 474,290
commonStore: size = 42
  # MissingInfos = 5,503
  MissingInfos size = 11,334
mcMissingCandidatesStore: size = 721
  # MissingInfos = 10,468
  MissingInfos size = 25,942

After step C:

store: size = 3574
  # MissingInfos = 201,668
  MissingInfos size = 470,283
commonStore: size = 42
  # MissingInfos = 5,568
  MissingInfos size = 11,783
mcMissingCandidatesStore: size = 621
  # MissingInfos = 9,823
  MissingInfos size = 24,206

After Step D:

store: size = 2110
  # MissingInfos = 90,805
  MissingInfos size = 197,335
commonStore: size = 42
  # MissingInfos = 5,568
  MissingInfos size = 11,783
mcMissingCandidatesStore: size = 621
  # MissingInfos = 9,823
  MissingInfos size = 24,206

For lazySet, after step E, and a bound of 35. 

store: size = 188775
  # MissingInfos = 56,527,767
  MissingInfos size = 152,521,419
commonStore: size = 3278
  # MissingInfos = 7,598,592
  MissingInfos size = 216,095,238
mcMissingCandidatesStore: size = 93192
  # MissingInfos = 84,263,788
  MissingInfos size = 10,183,639,695



=======

Trace sequence of calls process -> processTransition ->
instantiateTransitionTemplateBy -> extendTransitionTemplateBy -> isExtendable
-> findReferencingView: is there repeated work here?

* Look at the FIXMEs in Extendability.scala

* Avoid repeated work within calls to extendUnif

* With singleRef, in effectOn, if a secondary component c1 gains a reference
  to another component c2, we form the corresponding view c1 || c2 (via
  c2Refs).  Could we achieve the same effect more simply via a call to
  effectOn for pre.principal || c2?

* Improve EffectOnStore and related code.

============

Within effectOn, we might need to delay adding Views for a number of reasons.

1. If one of preCpts or cpts has a missing reference to a component in the
other, but the corresponding view is not a current view -- already supported.
EffectOnStore stores a mapping missing -> nv indicating that if all of missing
are added, then nv can also be added.

2. If each of preCpts and cpts have the same missing reference, and there is
not some way of instantiating that state to give a current view.  Need to
store the principals of each, and the list of such missing identities, i.e. a
mapping (servers, princ1, princ2, pids) -> nv such that if for each pid in
pids there is a component c such that (servers || princ1 || c) and (servers ||
princ2 || c) are added, then nv can be added.


============

- Do profiling on lazySet.  First, correct Node to allow unlocking when
  marked.  Also send decoupling signal only for A nodes.

- Check every event includes at least one active process. 

- Allow user to specify that only a single referenced state is included in
  Views.

- In Unification.combineX, don't remap components with index in map fst unifs.
  Or remap each state in turn. (low priority)

- In allUnifs, if !changedServers, try to do unifiation of component that
  changes state first.

- Clear package.debugging.

- Why are so many Views/Transitions not new?

- In TransitionTemplates, if the missing component is not synchronising, and
  there's a reference to it from a present component, use that fact to improve
  searching (done?).

=============

Thoughts on adding concurrency.

In Checker:

- In first stage of each ply, need to protect nextNewViews, newTransitions,
newTransitionTemplates.  CAS on done before debugging.

- In second stage, need to protect sysAbsViews, transitions,
  transitiontemplates (if done concurrently).

- Need to protect System.mapCache and Checker.isExtendableCache


=======================================

Implementation notes.

Main state:

- sysAbsViews: ViewSet: all views found.

- nextNewViews: ArrayBuffer[ComponentView]: all new views found on the current
  ply, to be considered on the next ply.

- transitions: TransitionSet: the extended transitions found so far.  An
  extended transition represents the pre- and post-states and the event, and
  includes (1) all states referenced by the initial state of the principal
  component, (2) all other components synchronising on the transition, (3) all
  components to which a process gains a reference.

- transitionTemplates: TransitionTemplateSet: the transition templates found
  so far.  A transition template can be thought of as a transition with a
  "hole" for a component to be slotted into.  Formally it's a tuple (pre,
  post, id, oe) representing all transitions pre \union st --> post \union st'
  such that (1) st and st' have identity id; (2) pre is compatible with pre;
  (3) if oe = Some(e) then st -e-> st', otherwise st = st'.

- newTransitions: ArrayBuffer[Transition]: the new transitions found on the
  current ply.

??? Why not new transitionTemplates ???


In the first half of each ply, new views are added to nextNewViews; in the
secondhalf, they are added to sysAbsViews.  Likewise with Transitions.

The function process acts on a single view found on the previous ply. It
calculates all the transitions from the view, together with the identities of
other components relevant to the view.  It then calls processTransition on
each such transition.  It also calls effectOfPreviousTransitions and
effectOfPreviousTransitionTemplates on the view.

processTransition: if the transition is complete, requires no outside
processes, it is added to newTransitions (via addTransition).  Otherwise, it
is added to transitionTemplates ???, and instantiateTransitionTemplate is
called. 

addTransition adds a transition to newtransitions, and calls effectOnOthers

effectOnOthers considers the effect of a new transition on views found on
previous plys (what about this ply???).  For each such view matching the pre
servers, it calls effectOn.

effectOn considers the effect of a transition pre -e-> post on another view
cv.  It forms all ways of combining pre and cv, calculates the corresponding
post-view for cv.princ, and adds it to nextNewViews. 

instantiateTransitionTemplate considers all ways of instantiating a transition
template, by considering all ways of instantiating the extra component.  For
each view in sysAbsViews, it calls instantiateTransitionTemplateBy.

instantiateTransitionTemplateBy finds all transitions of the extra component
that match the transition template.  For each, it forms the extended
transition, and calls addTransition. 

effectOfPreviousTransitions considers the effect of all previous transitions
on a view cv found on the previous ply.  For each, it calls effectOn. 

effectOfPreviousTransitionTemplates, given a view cv found on the previous
ply, iterates over all previous transition templates, and tries to use cv to
instantiate the extra component, calling instantiateTransitionTemplateBy.

======================================================

With lockBasedStack.csp, debugger gives error when selecting "6".  The
concretization does not include the node N1 referenced by N0.  Need to store
the contributing view(s) for each concretization.  Done: used in
Debugger.expandConc.  This needs testing more.  It might be that
lockBasedStack needs a second synchronisation between thread and watchdog.
But the debug info isn't clear at present.  I think the contributing view also
needs to be stored at l463 of Checker.scala.

=======================================================

We need to consider:

1. Transitions from new abstractions.  process -> processTransition.
  * Giving new TransitionTemplates
  * Giving new ExtendedTransitions

2. The effect of previous extended transitions on new abstractions.
process -> effectOfPreviousTransitions -> effectOn

3. The effect of new abstractions on previous transition templates, creating
new extended transitions.  processTransition -> addTransition ->
effectOnOthers -> effectOn.

4. The effect of new extended transitions on previous abstractions.
effectOfOthers -> effectOn.


ExtendedTransitions include all the components that synchronise on the
transition.  Do they also include all the components to which a process
receives a reference, e.g. in a getNext.T0.N0.N1 transition?  I think such
cases have to be treated as transition templates, since if we find a new state
for N1 subsequently, that will create a new ExtendedTransition.  However, if
the principal component passes a reference to another component or a server,
e.g. a setNext.T0.N0.N1 transition, then the component for that reference will
be held by the principal in the prior state and so will be in the prior view.

===================================

Def: a concretization conc is strongly consistent with a set V of views if
there exists a global state g \in gamma(V) such that conc \sqsubseteq g.

This is too strong for algorithmic checking, so we overapproximate it by the
following condition. 

Def: a concretization conc is weakly consistent with a set V of views if for each
component state st in conc, there is a view v \in V where st is the principal
component, and v and conc agree on common processes (i.e. they agree on the
states of servers and of all components with common identities).

Say "consistent" for "weakly consistent". 

Lemma: strongly consistency implies consistency.  

Proof: suppose conc strongly consistent with V.  So there is some g \in
gamma(V) such that conc \sqsubseteq g.  So \alpha(g) \subseteq V.  Consider a
component state st in conc, and let v \in \alpha(g) be the view of g with st
as the principal component.  Then v satisfies the requirement of consistency.

So we can safely overapproximate the strongly compatible components by the
compatible ones.  (I don't think the converse holds.)

Def: Suppose st is a component state whose identity is not in the
concretization conc.  Then, given a set V of views, st is strongly consistent
with conc and V if conc U st is strongly consistent with V.

Conj: Suppose st is strongly consistent with conc and V.  Then (1) conc is
strongly consistent with V; (2) there is a view v \in V where st is the
principal component, and v and conc agree on common processes; (3) for every
component st1 in v that has a reference to st, there is a view v \in V where
st1 is the principal component, and v and conc U st agree on common processes.

Proof: Suppose st is strongly consistent with conc and V.  So there is a
global state g \in \gamma(V) such that conc U st \sqsubseteq g.  So \alpha(g)
\subseteq V.  (1) So conc \sqsubseteq g, so conc strongly consistent with V.
(2) is satisfied by taking v \in \alpha(g) to be the view of g with st as the
principal component.  (3) similar but for st1. 



=========================================


Creating abstract transitions.

For the moment, ignore server views.

We need to perform a case analysis over the processes involved in the
synchronisation: 

* Just the principal component: done as Case 1. 

* Principal component + server: done as Case 2.

* Principal component + a passive component.  Subcase analysis:
  
  - That passive component is in the view: not yet done;

  - That passive component is not in the view: current focus **

* Principal component + server + passive component.  Not yet done; similar
  subcase analysis. 


Then extracting views from the post-transition concretization.


Assumptions:

- Each synchronisation involves a principal component and at most one passive
  component (and maybe the servers).  