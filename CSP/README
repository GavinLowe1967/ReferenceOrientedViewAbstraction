Lock-based stack
================

Not using three-way synchronisations:

lockBasedStack0.csp: correct version of the lock-based stack, not using
three-way synchronisations.  286 abstractions.

lockBasedStack0Err1.csp: version where pop does not obtain lock.  Finds error. 

lockBasedStack0Err2.csp: version where push does not obtain lock.  Finds error.

With three-way synchronisations:

lockBasedStack.csp: correct version with three-way synchronisation.  274 -> 302
abstractions.

lockBasedStackErr1.csp:  version where pop does not obtain lock.  Finds error.

lockBasedStackErr2.csp:  version where push does not obtain lock.  Finds error.

lockBasedStackKeep.csp: version that gives an error, I think because of too
few synchronisations with the watchdog.

Lock-based queue
================

lockBasedQueue.csp: involves two synchronisations between thread and watchdog
on each of enqueueing and dequeueing.  Also artificially keeps the tail
node in an enqueueing thread's state. 538 abstractions -> 556 ??

Treiber Stack
=============

TreiberStack.csp: 2,780 states, ~7 sec.  This has a POR to force joined
events immediately after the corresponding CAS.

TreiberStack0.csp: finds a false positive.  It's not capturing the invariant
that at most one thread has created a new node.

TreiberStack1.csp: this works, but is less efficient, as it doesn't have the
POR.  7408 states, ~28 sec (with profiling)

Test files
==========

test-file.csp: file used for the unit tests.  125 states
